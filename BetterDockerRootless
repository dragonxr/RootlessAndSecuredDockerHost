#!/bin/bash

## written by a tired Engineer at God knows when in the morning,
## now with less root and more paranoia, coming to a console near you.
## Works for me, but might not have been checked with enough caffeine.

set -euo pipefail

LOGFILE="/var/log/docker-hardening.log"
DOCKER_USER="dockerservice"

REQUIRED_PACKAGES=(
"linux-headers-$(uname -r)"
ca-certificates
curl
gnupg
lsb-release
apparmor
apparmor-utils
auditd
fail2ban
uidmap
iptables
logrotate
iptables-persistent
netfilter-persistent
slirp4netns
fuse-overlayfs
dbus-user-session
openssl
jq
)

DOCKER_PACKAGES=(
docker-ce
docker-ce-cli
containerd.io
docker-buildx-plugin
docker-ce-rootless-extras
)
# --- End of Variables and Packages ---

# --- timestamped logger ---
log() {
  echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOGFILE"
}
# --- End of timestamped logger ---

# --- Pre-flight: must be root ---
ensure_root() {
  set -Eeuo pipefail
  IFS=$'\n\t'
  [[ $EUID -eq 0 ]] || { echo "Run as root"; exit 1; }
  command -v systemctl >/dev/null || { echo "systemd required"; exit 1; }
  command -v apt-get   >/dev/null || { echo "apt required"; exit 1; }
  OS_ID="$(. /etc/os-release; echo "${ID}")"
  OS_CODENAME="$(. /etc/os-release; echo "${VERSION_CODENAME}")"
  ARCH="$(dpkg --print-architecture)"
}
# --- End of Pre-flight ---

# --- Retry apt operations to avoid lock contention ---
apt_retry() {
  local cmd="$*"
  local attempts=5
  until $cmd; do
    ((attempts--)) || {
      log "APT failed after retries: $cmd"
      exit 1
    }
    log "APT busy, retrying in 5s"
    sleep 5
  done
}
# --- End of Retry apt operations ---

# --- Install system deps if missing ---
install_packages() {
  log "---- Updating APT and installing system dependencies"
  apt_retry apt update
  apt_retry apt upgrade -y
  apt_retry apt dist-upgrade -y

  for pkg in "${REQUIRED_PACKAGES[@]}"; do
    if ! dpkg -s "$pkg" &>/dev/null; then
      log "Installing: $pkg"
      apt_retry apt install -y "$pkg"
    fi
  done

  for pkg in "${DOCKER_PACKAGES[@]}"; do
    if ! dpkg -s "$pkg" &>/dev/null; then
      log "Installing Docker package: $pkg"
      apt_retry apt install -y "$pkg"
    fi
  done
}
# --- End of Installing system deps ---

# --- Add Docker APT repository ---
add_docker_repo() {
  log "---- Checking Docker APT repo; adding if missing"

  local keyring="/etc/apt/keyrings/docker.asc"
  local repo_file="/etc/apt/sources.list.d/docker.list"
  local arch="$(dpkg --print-architecture)"
  local codename="$(. /etc/os-release; echo "$VERSION_CODENAME")"
  local dockerdownload="https://download.docker.com/linux/debian"

  if ! grep -q "download.docker.com" "$repo_file" 2>/dev/null; then
    log "---- Downloading and installing Docker GPG key"
    install -d -m 0755 /etc/apt/keyrings
    curl -fsSL "$dockerdownload/gpg" | safe_write_block "$keyring" 0644 root:root

    log "---- Adding Docker APT repository"
    cat <<EOF | safe_write_block "$repo_file" 0644 root:root
deb [arch=$arch signed-by=$keyring] $dockerdownload $codename stable
EOF

 apt_retry apt update

  else
    log "---- Docker APT repository already present"
  fi
}
# --- End of Adding Docker APT repository ---

# --- Verify essential binaries exist ---
validate_dependencies() {
  log "---- Validating essential Docker tools presence"
  command -v dockerd-rootless-setuptool.sh >/dev/null || { log "Missing dockerd-rootless-setuptool.sh"; exit 1; }
  command -v docker >/dev/null 2>&1 || { log "Missing docker CLI"; exit 1; }
  command -v newuidmap >/dev/null 2>&1 || { log "Missing uidmap"; exit 1; }
  command -v slirp4netns >/dev/null 2>&1 || { log "Missing slirp4netns"; exit 1; }
  command -v fuse-overlayfs >/dev/null 2>&1 || { log "Missing fuse-overlayfs"; exit 1; }
}
# --- End of Verifying essential binaries ---

# --- Atomic write: heredoc/pipe -> file (optional MODE, OWNER:GROUP) ---
# --- Usage because i keep forgetting and i keep causing EOF escapes
# --- cat <<'EOF' | safe_write_block /path/to/file [0600] [user:group]
# --- ...content that ill break ...
# --- EOF

safe_write_block() {
  local target="$1" mode="${2:-}" owner="${3:-}" lock="${1}.lock" dir base tmp _u _g
  [ -t 0 ] && { log "---- No stdin for $target"; return 1; }
  [ -L "$target" ] && { log "---- Refusing symlink: $target"; return 1; }

  dir="$(dirname -- "$target")"; base="$(basename -- "$target")"
 # Create parent dir only if missing; choose mode based on path so i dont break stuff again
 if [ ! -d "$dir" ]; then
   local dir_mode=0755
   case "$dir" in
     /home/*|/root/*) dir_mode=0700 ;;  # private user dirs only
   esac
   if [ -n "$owner" ]; then
     _u="${owner%%:*}"; _g="${owner#*:}"; [ "$_u" = "$owner" ] && _g="$_u"
     install -d -m "$dir_mode" -o "$_u" -g "$_g" "$dir" || { log "---- Cannot create dir $dir"; return 1; }
   else
     install -d -m "$dir_mode" "$dir" || { log "---- Cannot create dir $dir"; return 1; }
   fi
 fi

  exec 200>"$lock" || return 1
  flock -w 20 200 || { log "---- Lock timeout: $target"; return 1; }
  tmp="$(mktemp --tmpdir="$dir" ".${base}.XXXXXX")" || { flock -u 200; return 1; }

  cat >"$tmp" || { rm -f "$tmp"; flock -u 200; return 1; }
  [ -n "$owner" ] && chown "$owner" "$tmp" || true
  [ -n "$mode"  ] && chmod "$mode"  "$tmp" || true

  mv -f -- "$tmp" "$target" || { rm -f "$tmp"; flock -u 200; return 1; }
  flock -u 200
# --- Intentionally leave "$lock" to avoid races; harmless and conventional
  log "---- Wrote $target"
}
# --- End of headache of EOF with safe_write_block ---


# --- Create and configure non-root Docker user ---
create_user() {
  if ! id "$DOCKER_USER" &>/dev/null; then
    log "---- Creating non-root user: $DOCKER_USER"
    adduser --disabled-password --gecos "" "$DOCKER_USER"
  fi

  log "---- Ensuring subuid/subgid mappings"
  grep -q "^${DOCKER_USER}:" /etc/subuid || echo "${DOCKER_USER}:100000:65536" >> /etc/subuid
  grep -q "^${DOCKER_USER}:" /etc/subgid || echo "${DOCKER_USER}:100000:65536" >> /etc/subgid
  chmod 644 /etc/subuid /etc/subgid

  log "---- Adding $DOCKER_USER to docker group"
  usermod -aG docker "$DOCKER_USER"

  log "---- Ensuring home ownership"
  chown -R "$DOCKER_USER":"$DOCKER_USER" "/home/$DOCKER_USER"
  log "---- Ensuring home ownership done"
}
# --- End of Creating and configuring non-root Docker user ---

# --- Enable systemd lingering for rootless services ---
enable_lingering() {
  if ! command -v loginctl &>/dev/null; then
    log "loginctl not found; lingering not enabled"
    return 1
  fi

  if ! id "$DOCKER_USER" &>/dev/null; then
    log "User $DOCKER_USER does not exist; cannot enable lingering"
    return 1
  fi

# --- Try to get lingering status, suppress error messages
  local linger
  if ! linger=$(loginctl show-user "$DOCKER_USER" -p Linger --value 2>/dev/null); then
    log "User $DOCKER_USER has no session or lingering info, attempting to enable lingering..."
    if loginctl enable-linger "$DOCKER_USER"; then
      log "---- Lingering enabled for $DOCKER_USER"
    else
      log "Failed to enable lingering for $DOCKER_USER"
      return 1
    fi
    return 0
  fi

  if [[ "$linger" != "yes" ]]; then
    log "Lingering disabled for $DOCKER_USER; enabling now..."
    if loginctl enable-linger "$DOCKER_USER"; then
      log "---- Lingering enabled for $DOCKER_USER"
    else
      log "Failed to enable lingering for $DOCKER_USER"
      return 1
    fi
  else
    log "---- Lingering already enabled for $DOCKER_USER"
  fi
}
# --- End of Enabling systemd lingering for rootless services ---

# --- Set up rootless Docker daemon ---
setup_rootless() {
  log "---- Ensuring rootful Docker service and socket are stopped and disabled"
  if systemctl is-active --quiet docker.service; then
    log "Stopping docker.service"
    sudo systemctl stop docker.service
  fi
  if systemctl is-enabled --quiet docker.service; then
    log "Disabling docker.service"
    sudo systemctl disable docker.service
  fi
  if systemctl is-active --quiet docker.socket; then
    log "Stopping docker.socket"
    sudo systemctl stop docker.socket
  fi
  if systemctl is-enabled --quiet docker.socket; then
    log "Disabling docker.socket"
    sudo systemctl disable docker.socket
  fi
  systemctl mask docker.socket || log "Couldn't mask docker.socket"
  if [ -S /var/run/docker.sock ]; then
    log "Removing stale /var/run/docker.sock"
    sudo rm -f /var/run/docker.sock
  fi
  log "---- Setting up rootless Docker"
  sudo -Hu "$DOCKER_USER" env XDG_RUNTIME_DIR="/run/user/$(id -u $DOCKER_USER)" dockerd-rootless-setuptool.sh install || true
# --- Use explicit XDG_RUNTIME_DIR for systemctl --user calls
  sudo -Hu "$DOCKER_USER" env XDG_RUNTIME_DIR="/run/user/$(id -u $DOCKER_USER)" systemctl --user enable docker
  sudo -Hu "$DOCKER_USER" env XDG_RUNTIME_DIR="/run/user/$(id -u $DOCKER_USER)" systemctl --user start docker
}
# --- End of Setting up rootless Docker daemon ---

# --- Docker wait timer ---
wait_for_docker() {
  log "---- Waiting for rootless Docker to come online"
  local timeout=30
  until sudo -u "$DOCKER_USER" docker info &>/dev/null; do
    ((--timeout)) || {
      log "Docker did not start in time; check logs"
      exit 1
    }
    sleep 3
  done
  log "---- Docker is online"
}
# --- End of Docker wait timer ---

# --- Write user-level daemon.json with remap, logging, seccomp ---
configure_user_daemon() {
  log "---- Writing user-level Docker daemon config and hardened seccomp profile"

  local cfg_dir="/home/$DOCKER_USER/.config/docker"
  local sec_profile="$cfg_dir/seccomp.json"
  local daemon_config="$cfg_dir/daemon.json"
  local cert_dir="/home/$DOCKER_USER/.docker/certs"

# --- Create config directory
  sudo -u "$DOCKER_USER" mkdir -p "$cfg_dir"


# ---  Write the hardened seccomp profile (literal heredoc to prevent variable expansion)
cat <<'EOF' | safe_write_block "/home/$DOCKER_USER/.config/docker/seccomp.json" 0644 "$DOCKER_USER:$DOCKER_USER"

{
  "defaultAction": "SCMP_ACT_ERRNO",
  "architectures": [
    "SCMP_ARCH_X86_64",
    "SCMP_ARCH_X86",
    "SCMP_ARCH_X32"
  ],
  "syscalls": [
    {
      "names": [
        "accept",
        "accept4",
        "access",
        "alarm",
        "arch_prctl",
        "bind",
        "brk",
        "capget",
        "capset",
        "chdir",
        "chmod",
        "chown",
        "clock_gettime",
        "clone",
        "close",
        "connect",
        "creat",
        "dup",
        "dup2",
        "epoll_create1",
        "epoll_ctl",
        "epoll_pwait",
        "epoll_wait",
        "eventfd2",
        "execve",
        "exit",
        "exit_group",
        "faccessat",
        "fadvise64",
        "fallocate",
        "fanotify_mark",
        "fchdir",
        "fchmod",
        "fchmodat",
        "fchown",
        "fchownat",
        "fcntl",
        "fdatasync",
        "fstat",
        "fstatfs",
        "fsync",
        "ftruncate",
        "futex",
        "getcwd",
        "getdents",
        "getdents64",
        "getegid",
        "geteuid",
        "getgid",
        "getpid",
        "getppid",
        "getrandom",
        "getresgid",
        "getresuid",
        "getrlimit",
        "getrusage",
        "getuid",
        "inotify_add_watch",
        "inotify_init1",
        "inotify_rm_watch",
        "ioctl",
        "kill",
        "link",
        "linkat",
        "listen",
        "lseek",
        "lstat",
        "madvise",
        "memfd_create",
        "mkdir",
        "mkdirat",
        "mmap",
        "mprotect",
        "munmap",
        "nanosleep",
        "newfstatat",
        "open",
        "openat",
        "pause",
        "pipe",
        "pipe2",
        "poll",
        "ppoll",
        "prctl",
        "pread64",
        "pselect6",
        "pwrite64",
        "read",
        "readlink",
        "readlinkat",
        "recv",
        "recvfrom",
        "recvmsg",
        "rename",
        "restart_syscall",
        "rmdir",
        "rt_sigaction",
        "rt_sigpending",
        "rt_sigprocmask",
        "rt_sigqueueinfo",
        "rt_sigreturn",
        "rt_sigsuspend",
        "rt_sigtimedwait",
        "rt_tgsigqueueinfo",
        "sched_getaffinity",
        "sched_getparam",
        "sched_getscheduler",
        "sched_setscheduler",
        "sched_yield",
        "select",
        "semctl",
        "semget",
        "semop",
        "send",
        "sendmsg",
        "sendto",
        "set_robust_list",
        "set_tid_address",
        "setitimer",
        "setsid",
        "setsockopt",
        "shutdown",
        "sigaltstack",
        "signalfd4",
        "socket",
        "socketpair",
        "stat",
        "statfs",
        "symlink",
        "symlinkat",
        "sysinfo",
        "tee",
        "tgkill",
        "time",
        "timer_create",
        "timer_delete",
        "timer_getoverrun",
        "timer_settime",
        "times",
        "tkill",
        "truncate",
        "umask",
        "uname",
        "unlink",
        "unlinkat",
        "utime",
        "utimensat",
        "utimes",
        "wait4",
        "waitid",
        "waitpid",
        "write"
      ],
      "action": "SCMP_ACT_ALLOW"
    }
  ]
}
EOF

# --- Write Docker daemon config, referencing the seccomp profile path ---
cat <<'EOF' | safe_write_block "$daemon_config" 0644 $DOCKER_USER:$DOCKER_USER
{
  "userns-remap": "default",
  "no-new-privileges": true,
  "icc": false,
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  },
  "default-ulimits": {
    "nofile": {
      "Name": "nofile",
      "Hard": 64000,
      "Soft": 64000
    }
  },
  "seccomp-profile": "$sec_profile"
}
EOF

log "---- User-level Docker daemon configuration and seccomp profile written"
}
# --- End of Writing Docker daemon config, referencing the seccomp profile path ---

# --- Tighten containerd via systemd override ---
configure_system_daemon() {
  log "---- Applying systemd override for containerd"
  mkdir -p /etc/systemd/system/containerd.service.d
  cat <<'EOF' | safe_write_block /etc/systemd/system/containerd.service.d/override.conf 0644 root:root
[Service]
LimitNOFILE=65536
ProtectSystem=full
ProtectHome=yes
EOF
  systemctl daemon-reload
  systemctl restart containerd
}
# --- End of Tightening containerd via systemd override ---

# --- Generate and wire TLS certs into global daemon.json ---
setup_tls() {
  local cert_dir="/home/$DOCKER_USER/.docker/certs"
  log "---- Setting up TLS certs for rootless Docker API"

  if [[ ! -d "$cert_dir" ]]; then
    sudo -u "$DOCKER_USER" mkdir -p "$cert_dir"

    sudo -u "$DOCKER_USER" openssl genrsa -out "$cert_dir/ca-key.pem" 4096
    sudo -u "$DOCKER_USER" openssl req -x509 -new -nodes -key "$cert_dir/ca-key.pem" -sha256 -days 365 -out "$cert_dir/ca.pem" -subj "/CN=docker-ca"

    sudo -u "$DOCKER_USER" openssl genrsa -out "$cert_dir/server-key.pem" 4096
    sudo -u "$DOCKER_USER" openssl req -new -key "$cert_dir/server-key.pem" -out "$cert_dir/server.csr" -subj "/CN=$(hostname)"

    sudo -u "$DOCKER_USER" openssl x509 -req -in "$cert_dir/server.csr" -CA "$cert_dir/ca.pem" -CAkey "$cert_dir/ca-key.pem" -CAcreateserial \
      -out "$cert_dir/server-cert.pem" -days 365 -sha256

    sudo chmod 600 "$cert_dir"/*.pem
    sudo chown -R "$DOCKER_USER":"$DOCKER_USER" "$cert_dir"

    local daemon_config="/home/$DOCKER_USER/.config/docker/daemon.json"

# --- Ensure daemon config exists or create empty JSON object
    if [[ ! -f "$daemon_config" ]]; then
      sudo -u "$DOCKER_USER" mkdir -p "$(dirname "$daemon_config")"
      echo "{}" | sudo -u "$DOCKER_USER" tee "$daemon_config" > /dev/null
    fi

# --- Update daemon.json to enable TLS and listen on TCP + unix socket
    sudo -u "$DOCKER_USER" jq \
      '. + {
        "hosts": ["unix:///run/user/'"$(id -u "$DOCKER_USER")"'/docker.sock", "tcp://0.0.0.0:2376"],
        "tls": true,
        "tlsverify": true,
        "tlscacert": "'"$cert_dir"'/ca.pem",
        "tlscert": "'"$cert_dir"'/server-cert.pem",
        "tlskey": "'"$cert_dir"'/server-key.pem"
      }' "$daemon_config" > "$daemon_config.tmp" && sudo -u "$DOCKER_USER" mv "$daemon_config.tmp" "$daemon_config"

# --- Instead of restarting the service directly, use lingering and a user session to get around some annoyances and excessive caffine intake.
      log "---- Restarting rootless Docker to apply TLS config"
      if runuser -l "$DOCKER_USER" -c "XDG_RUNTIME_DIR=/run/user/$(id -u $DOCKER_USER) systemctl --user restart docker"; then
      log "---- Rootless Docker restarted successfully"
     else
      log "Failed to restart Docker via systemctl --user (missing session bus)"
      log "Try manually: sudo -u $DOCKER_USER systemctl --user restart docker"
     fi
  else
    log "---- TLS certs already exist"
  fi
}
# --- End of Generating wire TLS certs into global daemon.json ---

# --- AppArmor profile for the Docker user ---
setup_apparmor() {
log "---- Creating AppArmor profile for $DOCKER_USER"
  local profile="/etc/apparmor.d/${DOCKER_USER}"

cat <<EOF | safe_write_block "$profile" 0644 root:root
#include <tunables/global>
profile ${DOCKER_USER} flags=(attach_disconnected) {
# Basic capabilities and file read access
# Deny reading/writing other users' home dirs or sensitive system files
# Allow standard file usage
file,
capability,
network,
# Deny access to all other home directories
deny /home/*/ r,
deny /home/*/** rwk,
# Explicitly allow access to dockeruser's home
/home/${DOCKER_USER}/ r,
/home/${DOCKER_USER}/** rwk,
# Prevent umount operations
deny umount,
}
EOF

apparmor_parser -r "$profile" || { log "AppArmor parse failed"; exit 1; }
aa-enforce "docker-${DOCKER_USER}" || { log "AppArmor enforce failed"; exit 1; }
systemctl reload apparmor
  if ! aa-status | grep -q "docker-${DOCKER_USER}"; then
    log "Profile docker-${DOCKER_USER} NOT enforced!"
    exit 1
  fi
}
# --- End of AppArmor profile for the Docker user ---

# --- Auditd rule for docker exec calls ---
setup_auditd() {
  log "---- Applying auditd rule for docker exec"
if ! grep -q "/usr/bin/docker.*-k docker_exec" /etc/audit/rules.d/docker.rules 2>/dev/null; then
cat <<'EOF' | safe_write_block /etc/audit/rules.d/docker.rules 0640 root:root
-w /usr/bin/docker -p x -k docker_exec
-w /usr/bin/docker -p x -k docker_run
-w /usr/bin/docker -p x -k docker_cp
EOF

    augenrules --load
  else
    log "---- Auditd rule already present"
  fi
}
# --- End of Auditd rule for docker exec calls ---

# --- Install Falco via official APT repo on Debian ---
install_falco() {
  log "---- Installing Falco for runtime visibility"
  if ! command -v falco &>/dev/null; then
# --- Add apt-transport-https for older Debian versions
    apt_retry apt install -y apt-transport-https || true

    log "---- Import Falco GPG key"
    curl -fsSL https://falco.org/repo/falcosecurity-packages.asc | gpg --dearmor -o /usr/share/keyrings/falco-archive-keyring.gpg

    log "---- Add Falco repository"
    echo "deb [signed-by=/usr/share/keyrings/falco-archive-keyring.gpg] https://download.falco.org/packages/deb stable main" | safe_write_block /etc/apt/sources.list.d/falcosecurity.list 0644 root:root

    export DEBIAN_FRONTEND=noninteractive
    export FALCO_DRIVER_CHOICE=ebpf

    apt_retry apt update
    apt_retry apt install -y dialog falco

    log "---- Falco installed successfully"
  else
    log "---- Falco already installed"
  fi

  log "---- Enabling and starting Falco"
  systemctl enable falco
  systemctl restart falco

  if systemctl is-active --quiet falco; then
    log "Falco is running"
  else
    log "Falco failed to start; check 'journalctl -u falco'"
    exit 1
  fi
}
# --- End of Falco Install via official APT repo on Debian ---

# --- Disable default docker0 bridge and NAT rule ---
disable_default_bridge() {
  log "---- Disabling docker0 bridge"
  ip link set docker0 down 2>/dev/null || log "docker0 not found"
  iptables -t nat -D POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE 2>/dev/null || true
}
# --- End of Disabling default docker0 bridge and NAT rule ---

# --- Create internal Docker network securely ---
create_secure_net() {
  log "---- Creating internal Docker network 'secure_net'"
  if ! sudo -u "$DOCKER_USER" docker network ls --format '{{.Name}}' | grep -qw secure_net; then
    sudo -u "$DOCKER_USER" docker network create --driver bridge --internal secure_net
  else
    log "---- Network 'secure_net' already exists"
  fi
}
# --- End of Creating internal Docker network ---

# --- Configure Fail2Ban for Docker API abuse ---
setup_fail2ban() {
  log "---- Setting up Fail2Ban for Docker API"
cat <<'EOF' | safe_write_block /etc/fail2ban/filter.d/docker-api.conf 0644 root:root
[Definition]
failregex = .* "POST /v[0-9\.]+/containers/create HTTP/1.1" 403
ignoreregex =
EOF

cat <<'EOF' | safe_write_block /etc/fail2ban/jail.local 0644 root:root
[docker-api]
enabled = true
port = 2376
filter = docker-api
logpath = /var/log/syslog
maxretry = 3
EOF

systemctl restart fail2ban

}
# --- End of Fail2Ban for Docker API abuse ---


# --- Apply iptables rules and persist ---
setup_iptables() {
  log "---- Applying firewall rules for Docker API"
  iptables -C INPUT -p tcp --dport 2376 -s 127.0.0.1 -j ACCEPT 2>/dev/null || iptables -A INPUT -p tcp --dport 2376 -s 127.0.0.1 -j ACCEPT
  iptables -C INPUT -p tcp --dport 2376 -j DROP 2>/dev/null || iptables -A INPUT -p tcp --dport 2376 -j DROP

  log "---- Persisting iptables rules"
  if ! netfilter-persistent save; then
    log "netfilter-persistent failed-inspect /etc/iptables"
    exit 1
  fi
}
## --- End of iptables rules and persist ---

# --- Logrotate for rootless Docker logs ---
setup_logrotate() {
  log "---- Configuring logrotate for Docker logs"
chattr +i /var/log/auth.log
chattr +i /var/log/syslog
cat <<'EOF' | safe_write_block /etc/logrotate.d/docker 0644 root:root
/home/$DOCKER_USER/.local/share/docker/containers/*/*.log {
  rotate 7
  daily
  compress
  missingok
  delaycompress
  copytruncate
}
EOF
}

# --- Apply Kernal Hardening ---
configure_kernal_hardening() {
log "---- Configuring Kernal hardning and sysctl flags"

echo 2 > /proc/sys/kernel/kptr_restrict
echo 1 > /proc/sys/kernel/dmesg_restrict
echo 1 > /proc/sys/kernel/yama/ptrace_scope
echo 1 > /proc/sys/kernel/kptr_restrict
echo 1 > /proc/sys/kernel/dmesg_restrict
echo '* hard core 0' >> /etc/security/limits.conf
echo 0 > /proc/sys/kernel/core_pattern
}

# --- Final sanity checks ---
final_verification() {
  log "---- Final checks"

  if ! sudo -u "$DOCKER_USER" docker info | grep -iq rootless; then
    log "Docker is not running in rootless mode!"
  fi

  if command -v loginctl &>/dev/null; then
    [[ "$(loginctl show-user "$DOCKER_USER" -p Linger --value)" == "yes" ]] || log "Lingering is not enabled for $DOCKER_USER"
  else
    log "Cannot verify lingering-loginctl missing"
  fi

  auditctl -l | grep -q docker_exec || log "Audit rule 'docker_exec' missing"
  aa-status | grep -q "docker-${DOCKER_USER}" || log "AppArmor profile not enforced"
  ss -tuln | grep -q :2376 || log "Docker API not listening on 2376"
}

# --- Main dispatcher, tweak shit here ---
main() {

  ensure_root
  add_docker_repo
  install_packages

  validate_dependencies

  create_user
  enable_lingering
  setup_rootless
  wait_for_docker

  setup_tls
  configure_user_daemon
  configure_system_daemon
  

  setup_apparmor
  setup_auditd
  install_falco
  disable_default_bridge
  create_secure_net
  setup_fail2ban
  setup_iptables
  setup_logrotate
  configure_kernal_hardening

  final_verification

  log "Docker hardening complete, maybe. If something breaks, at least it broke securely."
}

main "$@"
